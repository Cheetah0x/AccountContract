{"transpiled":true,"noir_version":"0.35.0+b848cc128d2dc2b461581f21a35509a1af9065a7-aarch64","name":"AccountGroup","functions":[{"name":"verify_private_authwit","is_unconstrained":false,"custom_attributes":["private","view"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_auth_witness","pack_returns_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"},"visibility":"private"},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"},"visibility":"private"},{"name":"cancellable","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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uTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHuTtHubtAubtAubtAubtAubs4SFkcKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHcXKHeXKHeXKHeXKHeXKHeXBymLE+XuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuEuXuCuXuCuXuCuXuCuXu6iBlcaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHcXaHc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FJgfFJgfFJgfFJgfFJgfFJgfFJgfFJgfVJgfVJgfVJgfVJgf1IOVzwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwrzgwbzgwbzgwbzgwbzg3aw8tlgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBhftBhftBhftBhftAPVj47zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86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DyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDxrMDxrMDxrMDxrMD9rBymeD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGH+UGH+UGH+UGH+UE/WPnsMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD8YMD8YMD8YMD8YMD8YByufA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHE+YHE+YHE+YHE+YH82Dlc8L8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YML8YMH8YMH8YMH8YMH8YB2sfC6YHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYHyyYH2yYH2yYH2yYH2yYH+yDlc8N84MN84MN84MN84MN84MN84MN84P9ZD+oh728sx7Vf6rntVef1z+3l7cet9ev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c6alJy9dfddW50xLa860tOZMS2vOtLTGTEt5jJmW8hgzLeUxZlrKY8y0lIfPaXXMtJTHmGkpjzHTUh5jpqU85kxLH2pJ9kWrc6alD7Uk+6LVOdPSh1qSfdHqnGlJ5kxLMmdakjnTEnpX92NbRS/qfnCrc6Yl9IruB7c6Z1r6WLu877c6Z1r6WLu877c6Z1r6WLu877c6Z1qas8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyzjm7vHPOLu+cs8s75+zyrjm7vGvOLu+as8u75uzyrsPntDpmWqo5u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q45u7xrzi7vmrPLu+bs8q4Ptct76bq16j+2+pGmpYtW/bmtWsZL7S5y0apErn5581iyvm/1j/Jj7/ITXf6K+lZ++4/l197l997lr63Lf/YO618rP9v05c2z065OnXYL2Y7825B99g7r92xV57Rqc1r1Oa2iJ4pfbfXuRL/Q08djW0VPKo9tFT3VPLZV9AT0yFb7+FDT0v1WP9S0dL/VDzUt3W/1Q01L91v1Oa2OmZb6GDMt9TFmWupjzLTUx5xpSeZM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Gqg2LJ8bls8Ny+eG5XPD8hn2NFCFPQ1UG5bPDcvnBctnmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB80mB80mB80mB80mB+0g5XPBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODDvODDvODDvODDvODfrDy2WF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+MGB+MGB+MGB+MGB+MA5WPgfMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDwbMDybMDybMDybMDybMD+bByueE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGE+cGC+cGC+cGC+cGC+cE6WPlcMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD9YMD/YMD/YMD/YMD/YMD/YByufG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YHG+YH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pZgzLT15L8+7tjpnWoo501LMmZZizrQUc6alnDMt5ZxpKedMSzlnWnrylqx3bXXOtJRzpqWcMy3lnGkp50xLNWdaqjnTUs2ZlmrOtPTknXXv2uqcaanmTEs1Z1qqOdNSzZmWes601HOmpZ4zLfWcaenJGyTftdU501LPmZZ6zrTUc6alnjMtrTnT0pozLa0509KaMy09eZ/ru7Y6Z1pac6alNWdaWnOmpTVmWqpjzLRUx5hpqY4x01IdY6alOnxOq2OmpTrGTEt1jJmW6hgzLdWHWpJ9v9UPtST7otU509KHWpJ90eqcaelDLcm+aHXOtCRzpiWZMy2hd3U/uNU50xJ6S/eDW50zLcH3cz+01TnT0sfa5X2/1TnT0sfa5X2/1TnT0pxd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z515xd3jVnl3fN2eVdc3Z595xd3j1nl3fP2eXdc3Z59+FzWh0zLfWcXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3XN2efecXd49Z5d3z9nl3c/e5W0ZL7W7yEWrErn65c1jyfq+1T/K173LN3T5K+pb+e0/lu97lx97l597l1/k8rNNX948z3u1VyFr6yVkz98i/hCyPafVNabVZ++wfs9W0VPCY1tFTxS/2urd2W+hp4/HtupzWkVPNY9tFT0BPbbVDzUt3W/1Q01L91v9UNPSvVbX8aGmpfutfqhp6X6rY6aldYyZltbhc1odMy2tY8y0tI4x09I6xkxL65gzLcmcaUnmTEsyZ1qSOdPSs3dYv2erc6YlmTMtyZxpSeZMSzJnWtI505LOmZZ0zrSkc6alZ++wfs9W50xLOmda0jnTks6ZlnTOtGRzpiWbMy3ZnGnJ5kxLz95h/Z6tzpmWbM60ZHOmJZszLdmcacnnTEs+Z1ryOdOSz5mWnr3D+j1bnTMt+ZxpyedMSz5nWvI501LMmZZizrQUc6almDMtPXuH9Xu2OmdaijnTUsyZlmLOtBRzpqWcMy3lnGkp50xLOWdaevYO6/dsdc60lHOmpZwzLeWcaSnnTEs1Z1qqOdNSzZmWas609Owd1u/Z6pxpqeZMSzVnWqo501LNmZZ6zrTE3mH92FbnTEvs3diPbdXntDpnWmLv535sq3OmpY+1y/t+q3OmpY+1y/t+q3OmpTm7vNecXd5rzi7vNWeX95qzy3vN2eW95uzyXmN2ea9jzC7vs9Up09LZ6pRp6Wx1yrR0tupzWp0yLZ2tTpmWzlanTEtnq1OmpbPVOdPSmF3eZ6tzpqUxu7zPVudMS2N2eZ+tzpmWxuzyPludMy2N2eV9tjpnWhqzy/tsdc60NGaX99nqnGlpzC7vs9U509KYXd5nq3OmpTG7vM9W50xLz97lfdjLO+tRfdXq8r69+fLV91tVi+6Xd7eU+v7lf3Qro7rVUd3aqG59VLcxqtsc1W2N6rZHdbsmdeujZqknL/s+a45b+aV/6vaPehRWj8HqcVg9v31OL3n5DpVyu6qnsm6v7u+r96/1JKyegtXTsHoWq57f31z84HoEVo/C6jFYPQ6rJ1jni3hyPvdxq+e84fbK8SlYPQ2rZ7HqyQNWD2x+Ttj8nM/NZ1W93YTXkj/9e73y3hH6clv9/O/KHy6P0vcuP/YuP/cuv/Yuv2FRslj1PHkR5XU9sFNRwU5FBbuV8/pyRCn128/8l5/cexVZ20tAWJf/8CP8+lLCx35Evv1H1Nt/RL/9R6w3/4jXl7099iPk7T9C3/4j7O0/wllp07AbAc2e7XLd3jyWrB//edmz3WX5vXf5a+vy17F3+bJ3+bp3+ew7Kpfl+97ls++oXJafrCngyTuQruuB3fNYrHsecrDuecjBuuchB+uehxysex5yPDf9r359I0fA6mH9elQO1q9H5WD9elQO1q9HRVi/HhURWD0Kq8dg9TjrfCGsu1YisHwWWD4LLJ8Fls8Ky2eFzc8Km58Vls+/T+0fXA9sflZYPissn5V1f0MUdn/DYPc3DJbPBstng93fMFg+GyyfDZbPBstng83PBpufHTY/O+z+hsPubzhsfobxSXHY/Q2H5bPD8tlh+eywfA5YPgcsnwOWzwHL52fzyct6YPNzsP5+Q4L19xsSsPsbAbu/kbD7GzA+KTA+KQm7v5GwfE5YPidsfk7Y/Jyw+Tlh83PB5ueCzc8Fm58LNj8X7P5Gwe5vFCyfC5bPBcvnguVzw/K5YfNzw+bnhuXz76vQB9cDm58bls8Ny+eG3d9o2P2NBbu/sWD5vGD5vGD3NxYsnxcsnxcsnxcsnxdsfl6s+VkP1vysB+v+hh6s+xt6sOZnPRx1vtCDdX9DYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5Qf98PPrge1vyswvr7DRXW32+osO5vqLDub6iy7m8ozA8qzA+qsu5vKMwPKswPKswPKswPqsLmZ4XNzwabnw02PxtsfjbY/PzkB4Jeni8Mdn8D5gcV5gcV5gcV5gcV5gcV9vhFhT1+UWF+UH/fDz64Htj8DPODCvOD6rD7Gw67vxGw+xsBy+eA5XPA7m/A/KDC/KDCHr+osMcvKuzxiwp7/KLCHr+oCbu/kbD7Gwmbn3/fDz72fJGw+xswP6gwP6gwP6gwP6gwP6gwP6gwP6gwP6i/7wcfXA9sfi7Y328U7O83CnZ/o2D3Nxp2fwPmBxXmB7Vh9zdgT5VU2FMltWH53LB8hvlBhflBhflBhflBhflBhflBXbB8XrB8hj1/UGHPH1TY8wcV9vxBgz1/0GDPHzTY8wcN9vxBO1j5bDA/aAcrn+1g5bMdrHy2A5bPAstngeWzwPJZYPkMe/6gwZ4/aDA/aDA/aDA/aDA/aDA/aDA/aDA/aDA/aArLZ4Xls8LyWWH5DHv+oMGeP2iw5w8a7PmDBnv+oMGeP2gwP2gwP2gGy2eD5bPB8tlg+eywfIb5QYP5QXNYPsOeP2iw5w+aw/LZYfkM84MG84MG84MG84MG84MG84MWsHwOWD7Dnj9osOcPGuz5gwZ7/qDBnj9osOcPGuz5gwZ7/qDB/KDB/KAlLJ8Tls8Jy+eE5XPB8rlg+VywfC5YPsOeP2iw5w8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA86zA86zA86zA86zA/6wcpnh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/nBgPnBgPnBgPnBgPnBOFj5HDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/mDA/mDA/mDA/mDA/mAcrnxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBxPmBwvmBwvmBwvmBwvmB+tg5XPB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDD/GDD/GDD/GDD/GAfrHxumB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9cMD+4YH5wwfzggvnBdbDyecH84IL5wQXzgwvmBxfMDy6YH1wwP7hgfnDB/OCC+cEF84ML5gcXzA8umB9cMD+4YH5wwfzggvnBBfODC+YHF8wPLpgfXDA/uGB+cMH84IL5wQXzgwvmBxfMDy6YH1wwP7hgfnDB/OCC+cEF84ML5gcXzA8umB9cMD+4YH5wwfzggvnBBfODC+YHF8wPLpgfXDA/uGB+cMH84IL5wQXzgwvmBxfMDy6YH1wwP7hgfnDB/OCC+cEF84ML5gcXzA8umB9cMD+4YH5wwfzggvnBBfODC+YHF8wPLpgfXDA/uGB+cMH84IL5wQXzgwvmBxfMDy6YH1wwP7hgfnDB/OCC+cEF84ML5gcXzA8umB9cMD+4YH5wwfzggvnBBfOD68l+UA97eWc9qv9Uz6vV9+3Nz1+NfXv9eu3latH98u6WUt+//I9ua1S3ParbNadbOY4nw813b1dmtfvbp/WSl4+Qcrs6TVTW7dX9/cHxl4KMVpDTCornFtTH7czepq8VlLSCilZQ076HFqyg3+enjy5IaAXRklpoSS20pJagFZS0gmhJLU0raMEK0oNW0HOTWlVfClIt+VNBr7x3hB4vbx5R+eMIrrp5/bZ5/b55/bSzjNLOMlq0ghr9LZfr9uaxZL3yLbf2rt+Ozet/9ZQnpX4r6stb3+vA2l4+xLr8lc/QJ3yGPeEz/AmfEU/4jHzCZ9TmPxeb56ptnqu+ea46+1Liun72pcR1/Qa7tvx99fvogmg3/512899pt5ScdkvJabeUgnZLKYRWkNIKoiV10JI6aEkdtKQOWlIHLamDltRJS+qkJXXSkjppSZ20pE5aUictqZOW1ElL6qQlddGSumhJXbSkLlpSFy2pi5bURUvqoiV10ZK6aEndtKRuWlI3LambltRNS+qmJXXTkrppSd20pG5aUi9aUi9aUi9aUi9aUi9aUi9aUi9aUi9aUi9aUi9YUssBS2o5YEktByyp5YAltRywpBYa/BQa/BQa/JQDltRy0JJaaEkttKQWWlILLamFltRCS2qhJTUNfgoNfgoNfgoNforSklppSa20pFZaUistqZWW1EpLaqUltdKS2mhJbbSkNlpSGy2pjZbURktqoyW10ZLaaElttKR2WlI7LamdltQ0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyg0oyis55V+KQj1wKUvBaGeuPSlINQjl86CWM8s/VIQ6qFLXwpCPXXpS0Goxy59KchpBaEevPSlIFpSsx5d+qUgWlKzHl56FsR6eumXgmhJzXp+6ZeCaEnNeoLpl4JoSc16humXgmhJzXqK6ZeCaEnNeo7pl4JoSc16kumXgmhJzXqW6ZeCaEm9aEm9aEm9aEm9YEmtByyp9YAltR6wpNYDltR6wJJaD1hS6wFLaj1gSa0HLKn1oCW10JJaaEkttKQWWlILLamFltRCS2qhJbXQklpoSa20pFZaUistqZWW1EpLaqUltdKSWmlJrbSkVlpSGy2pjZbURktqoyW10ZLaaElttKQ2WlIbLamNltROS2qnJbXTktppSe20pHZaUjstqZ2W1E5LaqclddCSOmhJHbSkDlpSBy2pg5bUQUvqoCV10JI6aEmdtKROWlInLamTltRJS+qkJTXNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKCrNKBrNKBrNKBrNKBrNKNoBS2qjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWjGUWnGUWnGUWnGUWnGUU/YEntNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKMYNKMYNKMYNKMYNKMYByypg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUg2YUk2YUk2YUk2YUk2YU84AlddKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYtKMYj7AKK7+9hHrqqDD7OWtz//2+vZ6yVffvfTW7vpWivlrLxa5dSvp37/4a7NrULMPsJUbNfvbZ6+1Xl6rhx4XzUbeXh0l31694pUXq0W/HEi1lPr+5V/L173Lt73L973Lj73Lz73Lr73L773Lf+51nR72rdnqP81Tr05ffXvz5at/u90nK9x3bPf8H//5f/7zv/zLP//3/+df/u2//ON//PO//eu/f/ni48v/8/rfmHvVy7eWfDcimP314OWvf0n9+pf0r3/J+uUvef2vke98yfm/5K/H7dXyzl84fv3C9m/fPqL61y/Uv37hq0We2ffyhd99c8j5L/nTIu9/ifz6l+ivf4n9+pf4r3/J6yflePmS76/GvnzJjz8fli8jr9W3f09dr/6g3i7zNOtPr/1SSnJKKU4pzSllPbCUtr99+5/8SezD3l7e9u1fvzRa63at+d0Y8fr73z34P/nr08e9v7/x+8dbvv/5v+zLK3/yK4/bJfzq+O56/6/jyk9+KXH3S/rXv2T98pf85Nb73S+RX/8S/fUvsV//Ev/1L4lf/5Jf/9evX//Xr1//169f/9fvX//X71//1//JDZ04bl/SP3yJ/fqX+K9/Sfz6l+Svf0n94pec/8u/vPLVf0/p/nYX2/NvRtTzf/6///g///kf//O//NOXK4Qv/9f/9a//5eWC4fyf//H//Y8//i/ni/9/","brillig_names":["get_auth_witness","enqueue_public_function_call_internal","call_private_function_internal","debug_log_oracle_wrapper","notify_set_min_revertible_side_effect_counter_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"12265343917440897559":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":12,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"},{"fields":[{"name":"address","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"secret_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"},{"fields":[{"name":"address","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"secret_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"}},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"}},{"name":"cancellable","type":{"kind":"boolean"}}],"kind":"struct","path":"AccountGroup::entrypoint_parameters"}}],"kind":"struct","path":"AccountGroup::entrypoint_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"AccountGroup::verify_private_authwit_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AccountGroup::verify_private_authwit_abi"}]}},"file_map":{"116":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"117":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"120":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\nunconstrained pub fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"122":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> Field {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> Field {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe {\n        notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter)\n    };\n}\n\nunconstrained pub fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"156":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"161":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"},"223":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    pedersen_hash_with_separator_noir(input, separator)\n}\n\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator_noir(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n"},"298":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"300":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"308":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"315":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        debug_log_oracle_wrapper(msg, args)\n    };\n}\n\nunconstrained pub fn debug_log_oracle_wrapper<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"},"316":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"332":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::poseidon2_hash_with_separator\n};\nuse dep::aztec::{context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        comptime {\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\")\n    },\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress\n) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime {\n        FunctionSelector::from_signature(\"consume((Field),Field)\")\n    },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(consumer: AztecAddress, chain_id: Field, version: Field, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime {\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\")\n    },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime {\n        FunctionSelector::from_signature(\"set_reject_all(bool)\")\n    },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n"},"333":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/authwit/src/auth_witness.nr","source":"#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n * \n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\nunconstrained pub fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n"},"334":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__FEE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize}\n};\nuse crate::entrypoint::function_call::FunctionCall;\n\n// 2 * 5 (FUNCTION_CALL_SIZE) + 2\nglobal FEE_PAYLOAD_SIZE: u32 = 12;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: u32 = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS: u32 = 2;\n\n// docs:start:fee-payload-struct\npub struct FeePayload {\n  function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n  nonce: Field,\n  is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Serialize<FEE_PAYLOAD_SIZE> for FeePayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; FEE_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, FEE_PAYLOAD_SIZE> = BoundedVec::new();\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            fields.extend_from_array(self.function_calls[i].serialize());\n        }\n        fields.push(self.nonce);\n        fields.push(self.is_fee_payer as Field);\n        fields.storage\n    }\n}\n\nimpl Hash for FeePayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__FEE_PAYLOAD)\n    }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage\n    }\n\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n"},"335":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize}\n};\n\nuse crate::entrypoint::function_call::FunctionCall;\n\n// FUNCTION_CALL_SIZE * ACCOUNT_MAX_CALLS + 1\nglobal APP_PAYLOAD_SIZE: u32 = 21;\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\npub struct AppPayload {\n  function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Serialize<APP_PAYLOAD_SIZE> for AppPayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; APP_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, APP_PAYLOAD_SIZE> = BoundedVec::new();\n        for call in self.function_calls {\n            fields.extend_from_array(call.serialize());\n        }\n        fields.push(self.nonce);\n        fields.storage\n    }\n}\n\nimpl Hash for AppPayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n    }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"},"338":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/authwit/src/account.nr","source":"use dep::aztec::{\n    context::PrivateContext,\n    protocol_types::constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\n    hash::poseidon2_hash_with_separator\n};\n\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\nuse crate::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash};\n\npub struct AccountActions<Context> {\n  context: Context,\n  is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n *\n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /**\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     *\n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     *\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let valid_fn = self.is_valid_impl;\n\n        let combined_payload_hash = poseidon2_hash_with_separator(\n            [app_payload.hash(), fee_payload.hash()],\n            GENERATOR_INDEX__COMBINED_PAYLOAD\n        );\n        assert(valid_fn(self.context, combined_payload_hash));\n\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n        app_payload.execute_calls(self.context);\n        if cancellable {\n            let tx_nullifier = poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\n            self.context.push_nullifier(tx_nullifier);\n        }\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     *\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     *\n     * Will revert if the message is not authorized.\n     *\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can\n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"345":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"},"346":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::utils::compute_note_hash_for_nullify, oracle::random::random, keys::getters::get_nsk_app,\n    macros::notes::partial_note\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\n// docs:start:TokenNote\n#[partial_note(quote {amount})]\npub struct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:TokenNote\n\nimpl NullifiableNote for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER\n        )\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        Self { amount, npk_m_hash: owner_npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"347":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify, prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note\n};\n\nuse dep::std::mem::zeroed;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[note]\npub struct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nimpl NullifiableNote for TransparentNote {\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit.\n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier(self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        // compute_nullifier ignores both of its parameters so we can reuse it here\n        self.compute_nullifier(zeroed(), zeroed())\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"70":{"path":"/Users/niallcheetham/dev/aztec/priv2/accountContract/src/main.nr","source":"// Account contract that uses Schnorr signatures for authentication using a hardcoded public key.\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract AccountGroup {\n    use dep::aztec::prelude::PrivateContext;\n    use dep::authwit::{\n        entrypoint::{app::AppPayload, fee::FeePayload}, account::AccountActions,\n        auth_witness::get_auth_witness\n    };\n\n    use dep::aztec::macros::{functions::{private, view}};\n\n    global public_key_x: Field = 0x16b93f4afae55cab8507baeb8e7ab4de80f5ab1e9e1f5149bf8cd0d375451d90;\n    global public_key_y: Field = 0x208d44b36eb6e73b254921134d002da1a90b41131024e3b1d721259182106205;\n\n    // Note: If you globally change the entrypoint signature don't forget to update account_entrypoint.ts\n    #[private]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload, cancellable);\n    }\n\n    #[private]\n    #[view]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    #[contract_library_method]\n    fn is_valid_impl(_context: &mut PrivateContext, outer_hash: Field) -> bool {\n        // Load auth witness and format as an u8 array\n        let witness: [Field; 64] = unsafe {\n            get_auth_witness(outer_hash)\n        };\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n\n        // Verify signature using hardcoded public key\n        std::schnorr::verify_signature(\n            public_key_x,\n            public_key_y,\n            signature,\n            outer_hash.to_be_bytes::<32>()\n        )\n    }\n}"},"72":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/address-note/src/address_note.nr","source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"},"79":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\nunconstrained pub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"95":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"}}}